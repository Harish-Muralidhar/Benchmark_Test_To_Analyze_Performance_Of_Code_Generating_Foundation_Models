"""

Input:
2
1 1
1 1

Output:
-1

Input:
1
1

Output:
1

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
3
1 2 3
3 2 1
3 2 1

Output:
1 2 3

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

Input:
3
1 2 3
4 5 6
7 8 9

Output:
3 2 1

Input:
2
1 1
1 1

Output:
-1

Input:
1
1

Output:
1

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
3
1 2 3
3 2 1
3 2 1

Output:
1 2 3

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

Input:
2
1 1
1 1

Output:
-1

Input:
1
1

Output:
1

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
3
1 2 3
3 2 1
3 2 1

Output:
1 2 3

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

Input:
3
1 2 3
4 5 6
7 8 9

Output:
3 2 1

Input:
2
1 1
1 1

Output:
-1

Input:
1
1

Output:
1

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
3
1 2 3
3 2 1
3 2 1

Output:
1 2 3

Input:
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Output:
4 3 2 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
5
7 4 6 2 5
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4
5 6 2 7 4

Output:
2 3 5 4 1

Input:
6
1 3 1 2 3 1
1 2 3 1 2 3
1 1 1 1 1 1
3 2 1 3 2 1
3 2 1 3 2 1
3 2 1 3 2 1

Output:
6 5 1 4 3 2

"""

import sys

class Graph:
    def __init__(self, n):
        self.n = n
        self.graph = [[0 for col in range(n)] for row in range(n)]
        
    def addEdge(self, i, j, k):
        self.graph[i][j] = k
        
    def printGraph(self):
        for i in range(self.n):
            for j in range(self.n):
                print (self.graph[i][j]),
            print
        
    def isSafe(self, i, j, k):
        if (self.graph[i][j] > 0 and self.graph[i][j] < k):
            return False
        return True
        
    def solve(self, block, ind, i, j, k):
        #print (i, j)
        if (ind == len(block)):
            return True
        if (not block[ind]):
            block[ind] = i + 1
        if (i == j):
            if (ind == len(block) - 1):
                return True
            return self.solve(block, ind + 1, -1, -1, -1)
        if (not self.isSafe(i, j, k)):
            return False
        if (self.solve(block, ind, j, 0, k)):
            return True
        return self.solve(block, ind, i, j + 1, k)
        
def findBlock(n, k):
    g = Graph(n)
    for i in range(n):
        for j in range(n):
            g.addEdge(i, j, k[i][j])
    #g.printGraph()
    block = [None] * n
    if (g.solve(block, 0, 0, 0, 0)):
        return ' '.join([str(elem) for elem in block])
    return '-1'
    
def main():
    sys.setrecursionlimit(100000)
    t = int(raw_input())
    while t:
        t -= 1
        n = int(raw_input())
        k = []
        for i in range(n):
            k.append(map(int, raw_input().split()))
        print (findBlock(n, k))

if __name__ == '__main__':
    main()